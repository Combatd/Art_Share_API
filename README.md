# Art Share API
This project demonstrates Rails routing.

Each user has a set of artworks that they own/control. These artworks can also be shared with other users. An artwork that has been shared with one or more other users will be visible to those users, but the artwork still 'belongs to' the original user.

## Learning Goals
* Be able to create routes in routes.rb
* Be able to read and understand Rails server error messages
* Know the three places that params come from
* Be able to nest query parameters
* Be able to write controller actions that read from and write to the database
* Know how and when to render errors
* Be able to write Active Record models quickly
* Know how to write a user_params method
* Be able to write the five API RESTful controller methods
* Know how to test your API endpoints with Postman
* Know how to create and destroy join table records via controller methods
* Know how a nested route works

## First Routes
1. Setup database with ``` bundle exec rails db:create ```
2. Just for this assignment, add the line 
```config.action_controller.default_protect_from_forgery = false``` 
right after ```config.load_defaults 5.2``` in the config/application.rb file.
3. In config/routes.rb, generate first routes with:
```resources :users```
4. See first 8 routes with ```bundle exec rails routes```
5. Do the following:
* Comment out the resources :users line.
* Write out the eight routes using the route 'matching' syntax. For example: get 'users/:id', to: 'users#show', as: 'user'.
6. Run bundle exec rails routes again and ensure that the routes you've written match exactly the routes generated by the resources helper. NB: you'll probably be missing some names for some of the routes (they're listed in the left-most column); You can name your routes by adding an as option. get 'users/new', to: 'users#new', as: 'new_user'.

7. To give a little background, starting your Rails server creates an instance of a Router. This Router holds instances of Routes that are defined by your routes.rb. When a request comes in, the Router tries to match a Route based on the HTTP method and the url path (it does this with a regular expression, if you know what that is already). The first matched Route then instantiates an instance of the specified controller, and calls the specified action on it.

8. We have our initial routes now and have the endpoints necessary to manage a User resource. Notice though that our routes point to a UsersController, which we don't actually have yet. Nor do we have a User model. 

## First Controller

Each API endpoint creates/reads/updates/destroys (CRUD) a resource.

The router defines API endpoints (URLs), and records which controller and action to invoke for each one. Each API endpoint has a conventional meaning: create/read/update/destroy a resource. The controllers and their actions are the ones actually doing the CRUD ing.

I will create my first controller by navigating to ```app/controllers/``` and creating a new file called ```users_controller.rb``` 

``` 
class UsersController < ApplicationController
end
```
Note that controllers are always plural; a controller manages requests that pertain to a collection of resources. 
A resource is anything in your application that you will be CRUDing.

Controllers inherit from ApplicationController which is a controller itself, 
but one that never actually handles any requests directly. 
ApplicationController is where you'd put helper methods that you want 
to share across all controllers. 
ActionController::Base provides all the bells & whistles 
that Rails controllers have; it's like ActiveRecord::Base 
in that respect. All your controllers will inherit the features 
it provides since it is in the inheritance chain:

```UsersController < ApplicationController < ActionController::Base ```

## First Launch
We have our API endpoints setup and they map to a controller which we've created. 
How do we actually start taking requests?

```
$ rails server
=> Booting Puma
=> Rails 5.1.2 application starting in development on http://localhost:3000
=> Run `rails server -h` for more startup options
Puma starting in single mode...
* Version 3.9.1 (ruby 2.3.1-p112), codename: Private Caller
* Min threads: 5, max threads: 5
* Environment: development
* Listening on tcp://0.0.0.0:3000
Use Ctrl-C to stop
```

Rails 5 ships with a web server called Puma.

As you can see, it loads your application in development mode 
(later we'll discuss the other two modes: production and testing), 
and is listening for requests at http://0.0.0.0:3000. 
The last part, :3000 specifies the port it is listening on. 
Rails defaults to port 3000 in development. 
The domain http://0.0.0.0 can be accessed from your browser as simply 
http://localhost.

In your browser, navigate to http://localhost:3000. 
Voila! A running Rails app with what will become a very familiar index page.

## First Request

Now let's try to get a list of all our users - our users index. 
This means we need to make a request that matches the HTTP verb and URI pattern that routes to 'UsersController#index'. 
If we bundle exec rails routes, we can see this is a GET request to '/users'. 
Go ahead and make that request with Postman. (Make sure to keep your rails server running in a terminal tab!)

Okay, that didn't work. Why?

The server log will be where you'll go to see what's going on in your application. 
All your puts and p statements in your application will also go to the server log. 
Always be looking at the server log; this is an essential debugging technique. 
We'll see what some of the most important information is in just a second. 
Here's what we see in the log:
```
Started GET "/users.html" for 127.0.0.1 at 2013-08-12 10:48:39 -0700

AbstractController::ActionNotFound - The action 'index' could not be found for UsersController:
```
Looks like a request came in; what's the error? It seems like it's complaining that 
we don't actually have an index action setup in our UsersController. 
Note that your application looked for an index action because the router specified 
that a GET request to /users maps to users#index, which is the Rails shorthand for UsersController#index.

Let's fix it. Add an empty index action to your UsersController:

```
class UsersController < ApplicationController
  def index
  end
end
```

Make the request in Postman again. It fails again, so look at the log:

```
Started GET "/users" for 127.0.0.1 at 2017-07-14 11:36:40 -0700
Processing by UsersController#index as */*
No template found for UsersController#index, rendering head :no_content
Completed 204 No Content in 178ms
```

NB: If you make a GET request through a browser at this point, you will get a 406 Not Acceptable status code.

This time, it's complaining that there's a missing template. Wait a minute; we never called render. 
Why is it trying to look for a template at all? 
Because in the absence of an explicit render statement, your controller will by default try to render a 
template with the same name as the controller action - 
in this case, it was looking for a template called index.html.erb in app/views/users.

We're not going to deal with views and templates just yet. To get rid of this error, let's just add a simple render:

```
class UsersController < ApplicationController
  def index
    render plain: "I'm in the index action!"
  end
end
```

Try again. It should work! Now take a look at the server log.

```
Started GET "/users" for 127.0.0.1 at 2017-07-14 11:43:06 -0700
Processing by UsersController#index as HTML
  Rendering text template
  Rendered text template (0.0ms)
Completed 200 OK in 1ms (Views: 0.6ms)
```

For every request, the server will tell you which controller and action is processing it. In this case, it was the UsersController's index action.

Woohoo! Your Postman request should have returned the string "I'm in the index action!" 

## Playing with Parameters

```
Started GET "/users?favorite_food=pizza" for 127.0.0.1 at 2017-07-14 11:51:31 -0700
Processing by UsersController#index as */*
  Parameters: {"favorite_food"=>"pizza"}
  Rendering text template
  Rendered text template (0.0ms)
Completed 200 OK in 2ms (Views: 1.3ms)
```
```
Started POST "/users" for ::1 at 2017-06-19 10:09:29 -0700

AbstractController::ActionNotFound (The action 'create' could not be found for UsersController):

```
* Add create method to the UsersController
```
class UsersController < ApplicationController
  def create
    render json: params
  end
end
```
* POST request to UsersController
```
{
  "fav_food": "pizza",
  "controller": "users",
  "action": "create"
}
```
* Nest your Parameters
```
<!-- in Postman's "Body" tab: -->
some_category[a_key]: 'another value'
some_category[a_second_key]: 'yet another value'
some_category[inner_inner_hash][key]: 'value'
something_else: 'aaahhhhh'

<!-- in the query string -->
'/users?some_category[a_key]=another+value&some_category[a_second_key]=yet+another+value'
<!-- ...etc. -->
```
After building out the rest of the CRUD routes, should be able to perform all the actions regarding the Users Table, with error handling.
```
def create
  user = User.new(params.require(:user).permit(:name, :email))
  if user.save
    render json: user
  else
    render json: user.errors.full_messages, status: :unprocessable_entity
  end
end
```

With the Users routes created, it is time to implement other functionality.

## Phase 1: Data Layer

In this first phase we're going to add the tables for users, artworks, and artwork shares. We are also going to write validations and associations linking them.

### User

For the user table you should have name and email columns from the first routes. Change the User model so that you only have one column: ```username```. Write new migrations to accomplish this. Enforce presence and uniqueness of username at both ActiveRecord and DB levels.

After you create each table and model, make sure to test that your associations and validations are working before moving on to the next step. We want to be absolutely sure our code is working before we move on to the next phase, otherwise building our API endpoints will be needlessly complicated.

### Artwork

For your artworks table you should have the following columns: ```title```, ```image_url```, and ```artist_id```. All of these should be present. Add ActiveRecord validations and DB constraints.

Ensure a single user cannot have two artworks with the same title. On the other hand, two different users can have artworks with the same title. In other words, two separate artists could both have artworks of their own named "Untitled", but a single artist should not be able to have two pieces with that same title.

This means that the ```artist_id``` and ```title``` combination must be unique. Enforce this at the DB and model levels. Here's some help for the model validation To add the DB constraint, consider what would happen if we added indexing and a uniqueness constraint to not one, but two columns. Check this Stack Overflow answer for more info

Add an index on ```artist_id``` so that we can quickly get all the artworks for a user. Also add associations between ```User``` and ```Artwork```. The association from ```Artwork``` to ```User``` should be called ```artist```. Note that our column in the ```artworks``` table does not have to be ```user_id``` despite being a foreign key to the ```users``` table. In this case, ```artist_id``` is much more descriptive and therefore preferable.

### ArtworkShare

The ```artwork_shares``` table is a join table. Its whole purpose is to link a User (the person viewing the artwork) with an ```Artwork```.

You'll need an ```artwork_id``` and ```viewer_id``` column. Again, prefer columns names that are more semantic (i.e. more descriptive of the relationship) when possible.

No null values! Two levels of validations/constraints. Ensures that a user cannot have a single Artwork shared with them more than once. We index to ```ArtworkShare```'s foreign key columns for fast lookup. NB: we almost always want to create indexes for any foreign keys, particularly if those foreign keys will be used in a ```has_many``` or a ```has_one``` relationship.

Then add associations connecting an ```ArtworkShare``` to both an ```Artwork``` and a ```User``` (name this association ```viewer```). Add a through association ```shared_viewers``` on ```Artwork```. ```Artwork#shared_viewers``` will return the set of users with whom an artwork has been shared.

There is a ```through``` association from ```shared_artworks``` on ```User```. ```User#shared_artworks``` will return the set of artworks that have been shared with that user (not the set of artworks that a user has shared with others).

## Users and Artworks API

The API describes how to expose your data and specifies how the outside world can interact with it. I will use the Postman web application to test each controller. The Rails server log will provide valuable insight to causes of errors when I have to debug.


* ```user_params helper method```
This method should be private. It requires the key :user in params, and permits each of the user attributes as keys in the nested hash.

* ```create (POST /users)```
Remember to use if user.save to check if validations passed. On error, this action should render validation errors using user.errors.full_messages. Set the status code to indicate error.

* ```destroy (DELETE /users/:id)```

This un-shares an Artwork with a User. To delete a share, the user should issue a DELETE to /artwork_shares/123, where 123 is the id of the ArtworkShare to destroy.

### User's Artworks: nested routes
We want to be able to fetch the Artworks of a particular user.
For example, you will be able to get user 1's artworks through ```GET /users/1/artworks```, user 2's through ```GET /users/2/artworks```, etc.

## Last Phase with Comments
* The ```CommentsController``` should have create, destroy, and index actions.
* In order to retrieve comments for an artwork or a user we want our index action to handle some additional params.
  *  ```user_id``` or an ```artwork_id```
It should now be possible to make GET requests to CommentsController#index and depending on the params provided either return comments made by a particular user or comments made on a particular piece of artwork.